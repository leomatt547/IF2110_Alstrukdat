{ List dengan first implicit direpresentasi menggunakan pointer }
constant Nil : ...
constant ValUndef : ...
type infotype : integer
type ElmtList : < Info : infotype, Next : address >
type address : pointer to ElmtList
type List : address
{ *** Selektor *** }
{ Jika L : List dan P : address, maka penulisan :
First(L) menjadi L; Next(P) menjadi P­.Next; Info(P) menjadi P­.Info }
{*** Predikat pemeriksaan *** }
function IsEmpty (L : List) --> boolean
{ Mengirimkan true jika list kosong, false jika tidak kosong }
function IsOneElmt (L : List) --> boolean
{ Mengirimkan true jika list hanya terdiri dari satu elemen }
{ *** Konstruktor *** }
procedure CreateEmpty (output L : List)
{ I.S. Sembarang; F.S. Terbentuk list L kosong sesuai definisi. Apabila gagal alokasi,
First(L) dan Last(L) menjadi Nil }
{ *** Manajemen Memory *** }
function Alokasi (X : infotype) --> address
{ Mengembalikan address hasil alokasi X. }
{ Jika alokasi berhasil, maka address tidak Nil, misalnya menghasilkan P, maka Info(P)=X
dan Next(P)=Nil. Jika alokasi gagal, mengembalikan Nil. }
procedure Dealokasi (input P : address)
{ I.S. P terdefinisi; F.S. P dikembalikan ke sistem }

procedure AddX (input/output T: TabInt, input X: integer)
{ I.S: T, X terdefinisi }
{ F.S: Jika T.Neff < IdxMax, maka X ditambahkan pada IdxMin,
elemen lain digeser, T.Neff bertambah (panggil prosedur AddXRek);
Kasus khusus: jika T.Neff = IdxMax maka X tidak ditambahkan }
Algoritma
    if (L.Neff <> IdxMax) then
        AddXRek(L,X,L.Neff)
    
procedure AddXRek (IO L: List, input X : integer, input I : integer)
Kamus Lokal
Algoritma
    if I = 0 then
        L.TI[I+1] <-- X
        L.Neff <-- L.Neff + 1
    else
        L.TI[I+1] <-- L.TI[I]
        AddXRek(L, X, I-1)

function CountPos (L:List) → integer
{ Menghasilkan banyaknya kemunculan bilangan positif (>0) pada L }
KAMUS
Algoritma
    if (IsEmpty(L)) then
        --> 0
    else
        if (Info(L) > 0) then
            --> 1 + CountPos(Next(L))
        else
            --> 0 + CountPos(Next(L))

function Fibonancci (N):
    if N = 0:
        return 0
    else if N = 1
        return 1
    else:
        return Fib(N-1) + Fib(N-2)

function IsEqual(L1,L2:List) → boolean
{ Menghasilkan true jika L1 dan L2 adalah list yang sama,
false jika tidak }
Kamus Lokal:
    equal : boolean
Algoritma
    depend on (L1,L2)
        (IsEmpty(L1) = IsEmpty(L2)) : equal <-- True
        (not(IsEmpty(L1)) = IsEmpty(L2)) : equal <-- False
        IsEmpty(L1) = not(IsEmpty(L2)) : equal <-- False
        (Info(L1) = Info(L2)) and (isEqual(Next(L1),Next(L2))) : equal <-- True
    --> found

function IsMember (L:List, X:infotype) → boolean
{ Menghasilkan true jika X adalah salah satu anggota list L,
false jika tidak }
KAMUS
Algoritma
    if (IsEmpty) then
        --> False
    else
        --> (Info(L)=X) or Ismember(Next(L), X)

procedure InsertLast (input/output L : List, input X : infotype)
{ I.S. L terdefinisi, mungkin kosong. X terdefinisi. }
{ F.S. X menjadi elemen terakhir L jika alokasi X berhasil. Jika alokasi gagal, L tetap.}
Kamus Lokal
    P : address
Algoritma
    if IsEmpty(L) then {basis}
        L <-- Alokasi(X)
    else
        InsertLast(Next(L),X)

procedure ListPlus (input L1,L2:List; output L3:List)
{ I.S. L1, L2 terdefinisi dengan dimensi yang sama,
mungkin kosong. }
{ F.S. L3 berisi elemen-elemen yang merupakan
penjumlahan elemen-elemen L1 dan L2 pada posisi
yang bersesuaian. }
Kamus Lokal:
    LTemp: List sementara
    sumT: Sum sementara
Algoritma
    if (IsEmpty(L1) and IsEmpty(L2)) then
        L3 <-- Nil
    else
        ListPlus(Next(L1), Next(L2), LTemp)
        sumT <-- Info(L1) + Info(L2)
        Lout <-- Konso(sumT, LTemp)

function Max(L : List, IAwal : integer) --> integer
{ Menghasilkan nilai maksimum dari tabel T }
{ Prekondisi: T tidak kosong }
{ Definisi rekursif pencarian nilai maksimum: }
{ Basis: IAwal = IAkhir: Max = T.TIIAwal
Rekurens: IAwal < IAkhir: max2(T.TIIAwal,Max(T,IAwal+1)) }
Kamus Lokal
Algoritma
    if IAwal = L.Neff then
        --> L.TI[IAwal]
    else
        if L.TI[IAwal] > Max(L, IAwal + 1) then
            --> L.TI[IAwal]
        else
            --> Max(L, IAwal + 1) 

procedure MinMax (input L:List, output min,max:integer)
{ I.S. L terdefinisi, tidak kosong }
{ F.S. min berisi nilai minimum elemen L,
max berisi nilai maksimum elemen L }
Kamus Lokal
m,n : integer
Algoritma
    if (IsOneElmt(L)) then
        Min <-- Info(L)
        Max <-- Info(L)
    else
        if (m < Min) then
            Min <-- m
        else if (n > Max) then
            Max <-- n
        else
            Min, Max = MinMax(Next(L))

function MinList (L : List) --> address
{ Mengembalikan alamat dari elemen yang memiliki nilai terkecil. Apabila ada lebih dari
satu elemen, maka yang dikembalikan adalah address elemen yang muncul terakhir.
Prekondisi: L tidak kosong }
Kamus Lokal
    M : integer
Algoritma
    if IsOneElmt(L) then {basis}
        --> Info(L)
    else
        M <-- MinList(Next(L))
        if Info(L) < M then
            M <-- Info(L)
        --> M

function NthElement (L : List, N : integer > 0) --> infotype
{ Mengembalikan nilai elemen ke-N list.
Mengembalikan ValUndef jika elemen list kurang dari N }
Kamus Lokal
    -
Algoritma
    if IsEmpty(L) or N = 1 then {basis}
        if IsEmpty(L) then {elemen list kurang dari N}
            --> ValUndef
        else {N = 1}
            --> Info(L)
    else
        --> NthElement(Next(L),N-1)

procedure Search (input X: integer, input T: TabInt, input IAwal: integer,
output Idx: integer, output found: boolean)
{ I.S: X, T terdefinisi, IdxMin ≤ IAwal }
{ F.S: Idx adalah nilai ditemukannya X di T pada interval
[IAwal..T.Neff], found = true jika ditemukan }
KAMUS Lokal
Algoritma
if (IAwal > L.Neff) then
    found <-- False
    Idx <-- -999
else
    if (L.TI.IAwal = X) then
        Idx <-- IAwal
        Found <-- True
        --> Idx, Found
    else
        Search(X, L, IAwal+1, Idx, found)


function Segitiga (N: integer) --> integer
Kamus Lokal

Algoritma
    if N = 1 then
        -->i
    else
        --> N + Segitiga(N-1)
        
procedure SortList (input/output L : List)
{ I.S. L terdefinisi, tidak kosong }
{ F.S. elemen-elemen L terurut membesar }
{ Proses: selection sort dengan memanfaatkan fungsi MinList }
Kamus Lokal
    PMin : address
    Temp : infotype
Algoritma
    if IsOneElmt(L) then {basis, list 1 elemen adalah list terurut}
        {do nothing}
    else
        PMin <-- MinList(Next(L))
        if PMin < Info(L) then {nilai terkecil di sisa list < current element}
            {tukar isi Info(PMin) dengan isi Info(L)}
            Temp <-- Info(PMin)
            Info(PMin) <-- Info(L)
            Info(L) <-- Temp
        {urutkan sisa list}
        SortList(Next(L))

function SumPos (L: List) → integer
{ Menghasilkan penjumlahan semua elemen bilangan positif (>0)
dari L.
L kosong menghasilkan 0. }
Algoritma
    if (IsEmpty(L)) then
        --> 0
    else
        if (Info(L) > 0) then
            --> Info(L) + SumPos(Next(L))  
        else
            --> SumPos(Next(L))
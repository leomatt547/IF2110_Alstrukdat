KAMUS
{ Deklarasi TYPE POHON BINER }
constant Nil: ... { konstanta pohon kosong, terdefinisi }
type infotype: ... { terdefinisi }
type address: ... { terdefinisi }
{ Type Pohon Biner }
type BinTree: address
type node: < Info: infotype, { simpul/akar }
Left: BinTree, { subpohon kiri }
Right: BinTree { subpohon kanan } >
{Cara akses/selektor, P: BinTree:
Akar(P), Left(P), Right(P)}
{ Tambahan struktur data list untuk pengelolaan elemen pohon }
type ElmtNode: < Info: infotype,
Next: addressList >
type ListOfNode: addressList
{ list linier yang elemennya adalah ElmtNode }

function Search (P: bintree, X:infotype) --> boolean
Kamus Lokal
-
Algoritma
    if (IsTreeEmpty(P)) then
        --> False
    else
        if Akar(P) = X then
            --> True
        else
            Search(Left(P),x) or Search(Right(P),X)

function IsSkewLeft (P: BinTree) → boolean
{ Mengirimkan true jika P adalah pohon condong kiri }
KAMUS LOKAL
ALGORITMA
    if (IsTreeOneElmt(P)) then
        --> True
    else
        if (Right(P) <> Nil) then
            --> False
        else
            --> IsSkewLeft(Left(P))

function IsSkewRight (P: BinTree) → boolean
{ Mengirimkan true jika P adalah pohon condong kanan }
KAMUS LOKAL
ALGORITMA
    if (IsTreeOneElmt(P)) then
        --> True
    else
        if (Left(P) <> Nil) then
            --> False
        else
            --> IsSkewRight(Right(P))

function Level (P: BinTree, X: infotype) → integer
{ Mengirimkan level dari node X yang merupakan salah satu daun
dari pohon biner P. Akar(P) level-nya adalah 1. Pohon P tidak
kosong dan elemen-elemennya unik. }
KAMUS LOKAL
ALGORITMA
if(IsTreeOneElmt(P))then
    --> 1
else
    if (Search(Left(P),X)) then
        --> 1+Level(Left(P),X)
    else {Search(Right(P),X)}
        --> 1+Level(Right(P),X)

procedure AddDaun (input/Output P: BinTree,input X, Y: infotype,
input Kiri: boolean)
{ I.S. P tidak kosong, X adalah daun Pohon Biner P }
{ F.S. P bertambah simpulnya, dengan Y sebagai anak kiri X (jika
Kiri), atau sebagai anak Kanan X (jika not Kiri). Jika ada lebih
dari satu daun bernilai X, Y ditambahkan pada daun paling kiri. }
KAMUS LOKAL
ALGORITMA
    if (IsTreeOneElmt(P)) then
        P1 ← AlokList(Y)
        if (Kiri) then
            Left(P) ← P1
        else
            Right(P) ← P1
    else
        if SearchDaun(Left(P),X) then
            AddDaun(Left(P),X,Y,Kiri)
        else
            AddDaun(Right(P),X,Y,Kiri)

function SearchDaun(input/output P: BinTree, input X:infotype) --> boolean
KAMUS LOKAL
ALGORITMA
    if (IsTreeOneElmt(P)) then
        --> (Akar(P) = X)
    else
        depend on P
            IsUnerLeft(P) : --> SearchDaun(Left(P),X))
            IsUnerRight(P) : --> SearchDaun(Right(P),X)
            IsBiner(P) : --> SearchDaun(Left(P),X)) or SearchDaun(Right(P),X)

procedure DelDaun (input/output P: BinTree,
input X: infotype)
{ I.S. P tidak kosong, minimum 1 daun bernilai X }
{ F.S. Semua daun yang bernilai X dihapus dari P }
KAMUS LOKAL
    temp : address
ALGORITMA
    if (IsTreeOneElmt(P) and (Akar(P) = X)) then
        temp <-- P
        P <-- Nil
        Dealokasi (temp)
    else
        DelDaun(Left(P),X)
        DelDaun(Right(P),X)

function MakeListDaun (P: BinTree) → ListOfNode
{ Jika P adalah pohon kosong, maka menghasilkan list kosong. }
{ Jika P bukan pohon kosong: menghasilkan list yang elemennya
adalah semua daun pohon P. Diasumsikan alokasi selalu berhasil. }
KAMUS LOKAL
    L: ListOfNode
    R: ListOfNode
ALGORITMA
    if (IsTreeEmpty(P)) then
        --> Nil
    else if (IsTreeOneElmt(P)) then
        --> Alokasi(Akar(P))
    else
        List L = MakeListDaun(Left(P))
        List R = MakeListDaun(Right(P))
        --> Concat(L, R)

function MakeListLevel (P: BinTree, N: integer) → ListOfNode
{ Jika P adalah pohon kosong, maka menghasilkan list kosong. }
{ Jika P bukan pohon kosong: menghasilkan list yang elemennya
adalah semua elemen pohon P yang levelnya=N, jika semua alokasi
berhasil. Diasumsikan alokasi selalu berhasil. }
KAMUS LOKAL
    L: ListOfNode
    R: ListOfNode
ALGORITMA
    if (IsTreeEmpty(P)) then
        --> Nil
    else if (N = 1) then
        --> Alokasi(Akar(P))
    else
        List L = MakeListLevel(Left(P), N-1)
        List R = MakeListLevel(Right(P), N-1)
        --> Concat(L, R)

function BSearch (P: BinTree, X: infotype) → boolean
{ Mengirimkan true jika ada node dari P (BST) yang bernilai X }
KAMUS LOKAL
ALGORITMA
    if(IsTreeEmpty(P)) then
        --> False
    else
        if (Akar(P) = X) then
            --> True
        else if (X > Akar(P)) then
            BSearch(Right(P), X)
        else (X < Akar(P)) then
            BSearch(Left(P),X)

function IsBTree (P: BinTree) → boolean
{ Mengirimkan true jika P adalah balanced tree. Asumsi: P tidak kosong}
KAMUS LOKAL
ALGORITMA
    if (IsTreeOneElmt(P)) then
        --> True
    else
        nbElmtL ← NbElmt(Left(P))
        nbElmtR ← NbElmt(Right(P))
        heightL ← Height(Left(P))
        heightR ← Height(Right(P))
        if (Abs(nbElmtL-nbElmtR)>1 or Abs(heightL-heightR)>1) then
            --> False
        else
            if (IsUnerRight(P) or IsUnerLeft(P)) then
                --> True
            else
                --> (IsBTree(Left(P)) and IsBTree(Right(P)))

function BuildBST (Infos:array [1..100] of integer,
Neff:integer) → BinTree
{Mengirimkan BST yang semua elemennya ada di Infos (tidak terurut dan tidak unik). Infos
selalu diisi dari 1. Neff adalah indeks terakhir Infos yang terdefinisi, 0 jika kosong.}
KAMUS LOKAL
    i : integer
ALGORITMA
if (Neff(Infos) = 0) then
    --> Nil
else
    i traversal [1..Neff]
        InsSearchTree(Infos[i], T)
    --> T

procedure InsSearchTree (input X: infotype, input/output P: BinTree)
{ Menambahkan sebuah node X ke pohon biner pencarian P }
{ infotype terdiri dari key dan count. Key menunjukkan nilai unik, dan }
{ Count berapa kali muncul }
{ Basis: Pohon kosong }
{ Rekurens: Jika pohon tidak kosong, insert ke anak kiri jika nilai < Key(P) }
{ Atau insert ke anak kanan jika nilai > Key(P) }
{ Perhatikan bahwa insert selalu menjadi daun terkiri/terkanan dari subpohon }
KAMUS LOKAL
ALGORITMA
    if (IsTreeEmpty(P)) then { Basis: buat hanya akar }
        MakeTree(X,Nil,Nil,P)
else {Rekurens}
    depend on X, Key(P)
        X.Key = Key(P): Count(P) ← Count(P) + 1
        X.Key < Key(P): InsSearchTree(X,Left(P))
        X.Key > Key(P): InsSearchTree(X,Right(P))

function CountNonDaun --> integer ≥ 0
    {CountNonDaun(P) mengembalikan jumlah simpul yang
    bukan merupakan simpul daun pada P}
REALISASI
    CountNonDaun(P):
        if IsTreeOneElmt(P) then 
            -->0 {basis, simpul daun}
        else 
            depend on Left(P), Right(P)
                IsTreeEmpty(Left(P)) and not IsTreeEmpty(Right(P)):
                    --> 1+CountNonDaun(Right(P))
                not IsTreeEmpty(Left(P)) and IsTreeEmpty(Right(P)):
                    --> 1+CountNonDaun(Left(P))
                else
                    --> 1+CountNonDaun(Left(P))+CountNonDaun(Right(P))

List2BBST(L):
if IsEmpty(L) then
 {basis, pohon kosong}
// \\
else
    let <ki,a,ka>=Partisi(L,NbElmt(L) div 2) in
        // List2BBST(ki) a List2BBST(ka) \\

function Partisi (input: List of integer, integer) --> List of integer, integer, List of integer
{Partisi(L,n) menghasilkan list L1, integer x,
dan list L2. L1 berisi n elemen pertama dari
L, x adalah elemen ke n+1, dan L2 berisi
elemen sisanya. Prekondisi: n<NbElmt(L)}
Algoritma
    Partisi(L,n):
    if n=0 then 
        <[], FirstElmt(L), Tail(L)>
    else let <l,m,r> = Partisi(Tail(L),n-1) in
        <konso(FirstElmt(L),l),m,r>